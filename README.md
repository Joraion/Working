# # jorion

java 有6种基本数据类型,

包括整数类byte.int. short.long

浮点类float.double

字符类char

布尔类boolean

其中整数类能由小转大 即 byte→short→int→long,若需要由long往byte转,则会损失精度.

Java中的常量与变量:常量为基本不变的数,如1.2.3.4,变量即 为随机赋值的常量,即a = 1.2.3

字符串:即将一堆字符拼接到一起,用" " +  来表示,String为一个类 ,也可以将字符串总拼接.

自增/自减
前置自增:++a, 运算前先将变量+1之后再做相应运算
后置自增:a++, 做完相应运算后再将变量+1的运算,之后使用+1后的数值.
自减同理

赋值:为变量制定一个值之后做运算,Java里面可以对多个值同时赋值.

流程控制语句:
1.顺序结构
如
System.out.println("你好吗");
System.out.println("你在哪");
System.out.println("吃过饭了吗");
此次编译过后程序将在命令窗口依次打出"你好吗""你在哪""吃过饭了吗"

2分支结构
(1)if分支:


1)if(条件){
	若条件为TRUE(boolean 类型非TRUE即FALSE),则执行代码
}




2)if (条件){
	若条件为TRUE,执行此处代码
}else{
	若条件为FALSE,则执行此处代码
}




3)if(条件){
	若条件为true,执行此处代码
}else if(条件){
	若条件为TRUE,执行此处代码
}else if(条件){
	若条件为TRUE,执行此处代码
}else{
	若上述条件均为FALSE,则执行此处代码.
}
注:if只能有一个,而else if可以有多个甚至N个,else只能有一个或者零个





switch分支:
switch分支的类型可以是byte.short.int,char.string

switch(表达式)
case 值:
  若case值与表达式内类型值相等,则执行此处代码
break;
.....
default;
     若上述case值均不为表达式内类型值,则执行此处代码
break;

注:case 类可以有多个甚至N个,break为分支结束标志,若break去掉,则会出现将所有case后的执行代码
执行一遍.



循环结构:
(1)for循环
for(赋值语句;循环条件;迭代语句){
   此处为循环体
}

for(int a = 3;a<=5;a++)
{
   System.out.println("a=" + a);
}
当a的值大于5时循环结束

嵌套循环
for循环体内增加一个for循环

for(int a = 1;a<=4;a++){
	for(int b =2 ;b<=3,b++)	{
	System.out.println("a" + "b" "=" + a + b);
	}
	}


while循环:


int a =1

while(循环条件)
{
   循环体
   迭代语句
   }
循环体的循环条件 == 循环体执行次数 +1 



do while循环:

int a=1
do {
    循环体
   a++ 
   }
while(循环条件)
循环条件的次数 = 循环体执行的次数

两者区别:while循环先对循环条件进行判断,若条件为TRUE则进入循环体,直到循环条件为FALSE
         do while循环则无论条件正确与否都先执行一次循环体

例如:
int a = 4
while(a>=5)
{
   System.out.println("a" + "=" + a);
   a++}


int a = 4
do{
    System.out.println("a" + "=" + a);
    a++
    }
   while(a>=5)



最后while循环不执行循环体
而do while循环执行一次 输出a=5.





Java的三个关键词 break  , continue ,  return.

1,break 
主要为switch分支结构中结束某个当前分支的作用
	switch (条件)
	{
	case 值:
   //执行代码
	break;
	}
	default;


若为for循环
则:若为for内部循环则不影响外部循环.
   若要结束外部循环,则需要在外部for循环加上break标签.但不影响内部循环.


2,continue:
在嵌套循环中忽略本次满足的if条件的循环转而进行下一轮循环.
若要忽略外循环某一条件,则需在外循环中添加标签continue
continue不能用在switch分支中;


3,return:
用于直接结束程序,当条件满足时return将不再执行接下来的程序进而结束整个程序
将结果返还给上一级

数组:当有多个类型(byte short int long float double char)相同切功能相同的变量时
用数组将这些变量打包成一块即成数组

静态数组:
语法:
	
	(1)数组类型[] 数组名称 = new 数组类型[]{元素1,元素2,元素3,元素4);

	(2)数组类型[] 数组名称 = {元素1,元素2,元素3,元素4};
      
      	(3)数组类型 数组名称[] = {元素1,元素2,元素3,元素4};
 
 	获取数组的长度:
             
	     	System.out.println("数组名称.length+" + 数组名称.length);
 
 	获取数组中某一元素:
	         
		 	int 变量 = 数组名称[元素索引];注:第一个元素索引为0;
			
				System.out.println("数组名称[元素索引]=" + 变量); 
 
 	遍历数组中的所有元素:
		
 
	(1)for循环:
	 for (int A = 0;A<数组名称.length ;A++ )
	 {
			 System.out.println("数组名称["+A+"]="+数组名称[元素索引]);
	 }
		
		
		
         (2)while循环:
		int A = 0
		while (A<数组名称.length)
		{
			 System.out.println("数组名称["+A+"]="+数组名称[元素索引]);
			 A++;
		 }

	(3)for each
		for( int 变量F : 数组名称)
	{
			 System.out.println("变量F = " + 变量F);

	}

给数组中元素赋值:
	   数组名称[元素索引] = [数值];
		int 变量O = 数组名字[元素索引];
		
		
                                     面向对象总述
一.类中五大成分:
1,成员变量  
2,代码块
3,构造器
4,方法
5,内部类



1,成员变量:
定义在类之内,其他四大成分之外,可以为基本数据类型或者引用类型
[修饰符]<类型> 变量 [= 数值]

修饰符可以为public,static,private,不写,protected,final修饰
写法:一般为驼峰写法
int age = 0;
String name = "张帆";




static修饰的成员变量为静态成员变量,可直接用类方法进行调用
		类名.静态成员变量名();

无static修饰的成员变量为非静态成员变量,需创建对象才可进行调用
		类名 对象 =  new 构造器();
		对象.实例成员变量


2,代码块:
		实例代码块    {}
		静态代码块    static{}




分为静态代码块与非静态代码块.\
1)	有static修饰符修饰的即为静态代码块
  	静态代码块跟着类走,类加载一次静态代码块就加载一次,而且只加载一次
  	该代码块在main方法之前执行,只被执行一次
  


2)无static修饰的则为非静态代码块.亦称之为示例代码块
      示例代码块跟着对象走,每创建一个对象||实例,代码块就会被加载一次
       代码块在构造器之前执行一次,每创建一个对象调用构造器代码块就会被加载一次


  
  
3.构造器 : 
 1) 构造器作用:用于创建对象||实例,给对象实例化一些初始值
    格式:[修饰符]类名(形参列表){
	      //执行体
	}
    若一个类中无有参构造器,则默认构造器为无参构造器,程序员可以不写也可以写出来.
	this:  ①构造器中的this表示调用该构造器的对象,用于对调用该构造器的对象进行初始值的设置.
		   ②方法中 的this表示为调用该方法的对象,哪个创建的对象调用该方法就表示哪个对象.


4.方法:用来描述类或者对象的动作或行为的*
   [修饰符](void)  方法名称(形参列表){
				//方法体
   } 

1)[修饰符]:可以为权限修饰符,静态修饰符
			(静态修饰方法为静态方法,可直接用类来调用;非静态方法则需要通过对象进行调用)
	(void):返回值;若方法里无返回值则void不可以省略
			若有返回值void则不用写,在main方法中需定义一个新变量接受返回的值
  用类直接调用该方法:      类名.方法名称(形参列表); 类名可以省略
  用对象调用该方法:        对象.方法名称(形参列表);
	
  
  
  
  形参的可变方法:可以传递任意多个对应类型的参数,int ... num
			     当方法中有多个形参时可变形参需放在列表最后面
	


5.内部类:
定义在一个类中的另一个类,
1)静态内部类可以有成员变量,构造器,静态代码块,实例方法以及静态方法
  创建静态内部类方法对象  外部类名.内部类 变量 = new 外部类.内部类();
2)实例内部类不能定义静态代码块,实例方法,静态变量
  不能直接访问外部类静态成员
3)匿名内部类:用于接口和抽象类之中
	匿名内部诶必须重写所有的抽象方法,不能构造方法,不能定义任何静态成员   变量方法和静态类 
4)用于对数据更严密的封装,可用除   public   ,final ,abstract(外部类只能用这三种修饰符修饰)   外的  private,protected,static三种修饰符修饰
5)静态内部类不能直接访问外部类实例成员变量,只能访问静态成员变量,外部类也不能访问静态内部类成员变量
6)外部类可以通过外部类方法使用内部类类名调用成员变量进行 访问

public class neibulei {
	//外部类成员
	static int a = 10;
	String name = "热火";
	//定义内部类people
	public static class people {
		//内部类成员变量
		static int B = 30;
		int c = 3;
		//此入口不执行,执行外部类第一个入口main	
		public static void main(String[] args) {
			System.out.println(a);
		}

	}

	public static void main(String[] args) {
		//创建外部类实例
		neibulei A = new neibulei();
		//外部类实例调用该方法后访问内部类成员
		A.play();
		System.out.println(a);
	}

	public void play() {
		//通过内部类类名作为对象访问内部类静态成员
		System.out.println(people.B);
		//通过内部类实例对象访问内部类实例成员
		people num = new people();
		System.out.println(num.c);

	}

}

  


6.static 关键词:
 为静态修饰符  被static修饰的所有方法.成员变量,构造器,代码块.内部类 都为静态
1)静态方法:可直接用类名来调用  类名.方法(参数值);   用类名调用方法的时候类名可以省略
2)非静态方法:无static修饰词修饰的方法为实例方法,调用时需new 一个对象进行调用
						类名 变量 = new 构造器;
						变量.非静态方法名()
3)静态成员变量:可直接用类名来调用   类名.静态成员变量名称
  


7.值传递与类型数据的存储机制
  People people = new People("你好");
栈:存储基本类型变量的数据和对象的应用  People people 
堆:存放所创立的new 的对象以及参数值		new People("你好");
静态域:存放静态成员   int a
常量池:存放字符串和基本类型常量 10 ,String name = "你好"


8.包:公司域名反写.包名== 项目名称
   导包:import 包名称.类名  =====直接可以使用该包下面的类
        import 包名称.*   导出该包下面的所有类

9,java三大特征
封装:将成员变量尽量用权限修饰符隐藏,将方法公开
权限修饰符:private.public.protected.不写,
getter  setter方法

继承:
语法:类(子类) extends 另一个类(父类)
	 一个 类 只有一个直接父类  却可以拥有多个子类  obiect是所有类的直接或者间接父类
	 一个类继承另一个类之后能拥有该父类的方法以及成员变量
	 重写:子类调用父类方法并重新定义,重写的为实例方法
	 supr()  子类中一定会调用父类中的构造器,如果父类中无构造器,则会调用父类中默认的无参构造器
     若有无参与有参,super()在哪个构造器就首先调用哪个构造器


多态:多个类型相同的变量调用同一个方法输出不同的结果
     可以用父类接受子类创建的对象,属于向上转型
	 当要用父类转换成子类的时候需要强制转换
	 代码编译时看等号左边,执行时看真正指向的对象的类型

10.包装类
	java是一门可以将万物当做对象,在编译执行时模拟现实生活的编程语言
	将八个基本数据类型打包成可以当做对象处理的引用类型,引用类型成员变量默认值为null
	格式  int → Integer  char →  Character   其他六个均将首字母大写即可
	自动打包    java中能将基本数据类型自动转换成对应的引用类型实例
					int a = 10;
					Integer b = a;
					System.out.println(b);  b = 10;
	
	自动拆箱    java中能将包装类的引用类型自动转换成基本数据类型
					Integer B = 20;
					int A = B;
					System.out.println(A);  A  = 20;


final:
final修饰的方法不可重写
final修饰的成员变量必须有初始值,只能被赋值一次
final修饰的类不可被继承,可以成为别人的子类
final修饰的实例成员变量可以在构造器,代码块,定义时赋值,且只能被赋值一次




toString方法:
当创建一个对象时,直接打印对象则会打印出该对象的内存地址,实际上是对象调用了object中
toString方法,因为所有的类都间接或者直接继承object
而重写toString 方法能获取对象更完整的信息,对象自动调用重写的toString,返回值由开发者自己决定
而字符串String 和包装类默认重写了object中的tostring方法,使打印出来的是非内存地址


equals方法:
用于比较实例中两个对象所指的类型是否相等,a.equals(b)
object中默认有equals方法,用于判断两个对象的内存地址是否相等
若重写equals方法则能使同类型的两个对象相等,若一起重写hashcode则可以使两对象的内存地址表面上的相等
不过 == 是比较两者真正意义上的内存地址
如:
数据类型相同的 两个对象,重写equals与hashcode 方法后,
System.out.println(a.equals(b));结果为true
System.out.println(a == b);结果为false
一般重写equals方法后都一起重写hsahcode方法
Set集合中,判断两个元素是否重复时,先调hashcode方法判断两者内存地址是否相同,若结果相同则继续调用equals,若结果也相等则该元素重复


equals 与 == 区别:
equals 用于比较两个对象是否相等,不能用于基本类型的数据比较,基本数据类型无equals方法,但是基本类型的包装类可以通过equals方法比较(基本数据类型被包装之后成为引用类型,而引用类型有equals方法)
== 用于基本数据类型比较时只比较两者的值是否相等,用于比较两个对象(引用类型)时比较对象真正意义上的内存地址


抽象类:abstract 抽象修饰符,只能修饰类或方法
1)非抽象类不能定义抽象方法
2)抽象类中抽象方法可有可无
3)主要用于被继承,无法创建对象
4)子类继承抽象类,若不是抽象子类则必须重写抽象父类中所有抽象方法,成为创建对象实现父类方法的实现类
    若不重写父类中所有抽象方法则子类也必须为抽象类
5)抽象方法:   public void play();抽象方法无执行体

abstract,final,static
abstract抽象类与方法一般用于被继承被重写
final修饰的类成员不能被继承不能被重写
static修饰的静态方法也不能被重写



接口:
1,一个接口可以继承多个父接口,为多继承.而一个类只能继承一个类,为单继承
2,为一种更高级更规范的抽象类,故不能创建实例对象
3,定义接口中的成员变量,必须赋初始值并且不能更改,所有成员变量在接口中都会默认加上public  static final修饰符,为静态的
	只能被赋值一次的常量,即使两个类不在同一个包下面另一个类也能访问接口中的成员常量
4,当一个类实现接口时必须重写接口类的所有方法,若实现类不重写接口中方法,则该类必为抽象类
5,接口中不能定义实例方法, public void 方法名(){},除非是声明 default 的方法
6,接口中默认所有方法都为抽象方法,即使不加 abstract,在编译时都会自动加上abstract修饰词
7,可以定义静态方法
8,接口中default方法不能用接口直接调用,而实现类可以,创建实现类实例对接口中的default方法进行调用
9,实现类可以接收接口的实例,调用接口default方法
